# -*- coding: utf-8 -*-
"""OptimalTriangulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DFbZX5RVOrMQ5HplLPHW0bKu4ML4tQVR
"""





from google.colab import drive
drive.mount('/content/drive')

class vertex:
    x = 0.0
    y = 0.0


import math
import matplotlib.pyplot as plt

def Between(a, b, c):
    if not Collinear(a, b, c):
        return False
    if a.x != b.x:
        return (a.x <= c.x and c.x <= b.x) or (a.x >= c.x and c.x >= b.x)
    else:
        return (a.y <= c.y and c.y <= b.y) or (a.y >= c.y and c.y >= b.y)


def dist(v1, v2):
    return math.sqrt((v1.x - v2.x) * (v1.x - v2.x) +
                     (v1.y - v2.y) * (v1.y - v2.y))


def IntersectProp(a, b, c, d):
    if (Collinear(a, b, c) or Collinear(a, b, d) or Collinear(c, d, a) or Collinear(c, d, b)):
        return False
    return Xor(left(a, b, c), left(a, b, d)) and Xor(left(c, d, a), left(c, d, b))


def Intersect(a, b, c, d):
    if (IntersectProp(a, b, c, d)):
        return True
    elif Between(a, b, c) or Between(a, b, d) or Between(c, d, a) or Between(c, d, b):
        return True
    else:
        return False


def Collinear(a, b, c):
    return ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) == 0


def left(a, b, c):
    return ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) > 0


def leftOn(a, b, c):
    return ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) >= 0


def Xor(x, y):
    return (not x) ^ (not y)


def Diagonalie(i, j, n, vert):
    for k in range(n):
        k1 = (k + 1) % n
        if not ((k == i) or (k1 == i) or (k == j) or (k1 == j)):
            if (Intersect(vert[i], vert[j], vert[k], vert[k1])):
                return False
    return True


def InCone(i, j, n, vert):
    i_minus = (i - 1 + n) % n
    i_plus = (i + 1) % n
    if (leftOn(vert[i_minus], vert[i], vert[i_plus])):
        return left(vert[i], vert[j], vert[i_minus]) and left(vert[j], vert[i], vert[i_plus])
    else:
        return not (leftOn(vert[i], vert[j], vert[i_plus]) and leftOn(vert[j], vert[i], vert[i_minus]))


def Diagonal(i, j, n, vert):
    # print(InCone (i,j,n, vert), Diagonalie(i,j,n,vert))
    if (i == (j + 1) % n or i == (j + n - 1) % n):
        return True
    return (InCone(i, j, n, vert) and Diagonalie(i, j, n, vert))


def plot_tri(P, v, i, j, n, ax1, c):
    if i != j:
        k = P[i][j]
        if k == -1:
            return
        if i != (j + 1) % n and i != (j + n - 1) % n:
            x_val = [v[i].x, v[j].x]
            y_val = [v[i].y, v[j].y]
            ax1.plot(x_val, y_val, color=c)

        if i != (k + 1) % n and i != (k + n - 1) % n:
            x_val = [v[i].x, v[k].x]
            y_val = [v[i].y, v[k].y]
            ax1.plot(x_val, y_val, color=c)

        if k != (j + 1) % n and k != (j + n - 1) % n:
            x_val = [v[k].x, v[j].x]
            y_val = [v[k].y, v[j].y]
            ax1.plot(x_val, y_val, color=c)
        plot_tri(P, v, i, k, n, ax1, c)
        plot_tri(P, v, k, j, n, ax1, c)
        return


def buildVisibility(vert, n):
    visibility = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        for j in range(n):
            if Diagonal(i, j, n, vert):
                visibility[i][j] = 1
    return visibility


def PointAssign(a, b):
    a.x = b.x
    a.y = b.y


def ClipEar(i, n, vert):
    for k in range(i, n - 1):
        PointAssign(vert[k], vert[k + 1])


length = 0

def EarClipTriangulate(n, vert, ax2):
    global length
    if n > 3:
        for i in range(n):
            i1 = (i + 1) % n
            i2 = (i + 2) % n
            if Diagonal(i, i2, n, vert):
                # print('Edge', vert[i].x, vert[i].y, 'to', vert[i2].x, vert[i2].y)
                x_val = [vert[i].x, vert[i2].x]
                y_val = [vert[i].y, vert[i2].y]
                ax2.plot(x_val, y_val, color='g')
                length += dist(vert[i], vert[i2])
                ClipEar(i1, n, vert)
                EarClipTriangulate(n - 1, vert, ax2)
                break

def angle_cost(a,b,c):
  #We define the angle cost as the difference of longest side and the smallest side in a triangle. 
  d1 = dist(a,b)
  d2 = dist(b,c)
  d3 = dist(c,a)
  return max(d1, d2, d3) - min(d1, d2, d3)

def area(a, b, c):
  return abs((b.x - a.x) * (c.y - a.y) -(c.x - a.x) * (b.y - a.y))/2

def perimeter(a, b, c):
  return dist(a,b)+dist(b,c)+dist(c,a)

#minimizing the sum of diagonals of the triangulation 
def optimalTri(vert, n, visibility, P_opt):
    if (n < 3):
        return 0
    table = [[float('inf') for x in range(n)] for i in range(n)]
    i = 2
    while (i < n):
        j = (i - 2)
        while (j >= 0):
            if visibility[i][j] == 1:
                if j == (i + n - 2) % n:
                    table[i][j] = 0
                    P_opt[i][j] = (i + n - 1) % n
                else:
                    a1 = a2 = mini = float('inf')
                    k_hat = -1
                    for k in range(j + 1, i):
                        if k == i - 1 and visibility[k][j] == 1:
                            a1 = dist(vert[k], vert[j]) + table[k][j]
                        elif k == j + 1 and visibility[i][k] == 1:
                            a2 = dist(vert[k], vert[i]) + table[i][k]
                        else:
                            if table[i][k] + table[k][j] + dist(vert[k], vert[j]) + dist(vert[i], vert[k]) < mini:
                                k_hat = k
                            mini = min(mini,
                                       table[i][k] + table[k][j] + dist(vert[k], vert[j]) + dist(vert[i], vert[k]))
                    if mini <= a1 and mini <= a2:
                        P_opt[i][j] = k_hat
                    elif a1 <= mini and a1 <= a2:
                        P_opt[i][j] = i - 1
                    else:
                        P_opt[i][j] = j + 1
                    table[i][j] = min(a1, a2, mini)
            j -= 1
        i += 1
    return table

#Minimizing the difference between longest and shortest side of triangles in the triangulation
def optimalAngleTri(vert, n, visibility, P_opt):
  if n<3:
    return 0
  table = [[float('inf') for x in range(n)] for i in range(n)]
  i=2
  while i<n:
    j=i-2
    while j>=0:
      if visibility[i][j]==1:
        if j == (i + n - 2) % n:
          table[i][j] = angle_cost(vert[i], vert[j], vert[j+1]) #Base case 
          P_opt[i][j] = (i + n - 1) % n 
        else:
          a1 = a2 = mini = float('inf')
          k_hat = -1
          for k in range(j + 1, i):
            if k == i - 1 and visibility[k][j] == 1:
              a1 = angle_cost(vert[i], vert[k], vert[j]) + table[k][j]
            elif k == j + 1 and visibility[i][k] == 1:
              a2 = angle_cost(vert[j], vert[k], vert[i]) + table[i][k]
            else:
              if (table[i][k] + table[k][j] + angle_cost(vert[j], vert[i], vert[k])) < mini:
                k_hat = k
              mini = min(mini, table[i][k] + table[k][j] + angle_cost(vert[i], vert[j], vert[k]))
          if mini <= a1 and mini <= a2:
            P_opt[i][j] = k_hat
          elif a1 <= mini and a1 <= a2:
            P_opt[i][j] = i - 1
          else:
            P_opt[i][j] = j + 1
          table[i][j] = min(a1, a2, mini)
      j -= 1
    i += 1
  return table

#'Minimizing the area of the triangle with maximum area
def optimalAreaTri(vert, n, visibility, P_opt):
    if (n < 3):
        return 0
    table = [[float('inf') for x in range(n)] for i in range(n)]
    i = 2
    while (i < n):
        j = (i - 2)
        while (j >= 0):
            if visibility[i][j] == 1:
                if j == (i + n - 2) % n:
                    table[i][j] = area(vert[i], vert[j], vert[j+1])
                    P_opt[i][j] = (i + n - 1) % n
                else:
                    a1 = a2 = mini = float('inf')
                    k_hat = -1
                    for k in range(j + 1, i):
                        if k == i - 1 and visibility[k][j] == 1:
                            a1 = max(area(vert[i], vert[j], vert[k]), table[k][j])
                        elif k == j + 1 and visibility[i][k] == 1:
                            a2 = max(area(vert[i], vert[j], vert[k]), table[i][k])
                        else:
                            if max(table[i][k] , table[k][j] , area(vert[i], vert[j], vert[k])) < mini:
                                k_hat = k
                            mini = min(mini,
                                       max(table[i][k] , table[k][j] , area(vert[i], vert[j], vert[k])))
                    if mini <= a1 and mini <= a2:
                        P_opt[i][j] = k_hat
                    elif a1 <= mini and a1 <= a2:
                        P_opt[i][j] = i - 1
                    else:
                        P_opt[i][j] = j + 1
                    table[i][j] = min(a1, a2, mini)
            j -= 1
        i += 1
    return table

#Minimizing the maximum perimeter triangle
def optimalPerimeterTri(vert, n, visibility, P_opt):
    if (n < 3):
        return 0
    table = [[float('inf') for x in range(n)] for i in range(n)]
    i = 2
    while (i < n):
        j = (i - 2)
        while (j >= 0):
            if visibility[i][j] == 1:
                if j == (i + n - 2) % n:
                    table[i][j] = perimeter(vert[i], vert[j], vert[j+1])
                    P_opt[i][j] = (i + n - 1) % n
                else:
                    a1 = a2 = mini = float('inf')
                    k_hat = -1
                    for k in range(j + 1, i):
                        if k == i - 1 and visibility[k][j] == 1:
                            a1 = max(perimeter(vert[i], vert[j], vert[k]), table[k][j])
                        elif k == j + 1 and visibility[i][k] == 1:
                            a2 = max(perimeter(vert[i], vert[j], vert[k]), table[i][k])
                        else:
                            if max(table[i][k] , table[k][j] , perimeter(vert[i], vert[j], vert[k])) < mini:
                                k_hat = k
                            mini = min(mini,
                                       max(table[i][k] , table[k][j] , perimeter(vert[i], vert[j], vert[k])))
                    if mini <= a1 and mini <= a2:
                        P_opt[i][j] = k_hat
                    elif a1 <= mini and a1 <= a2:
                        P_opt[i][j] = i - 1
                    else:
                        P_opt[i][j] = j + 1
                    table[i][j] = min(a1, a2, mini)
            j -= 1
        i += 1
    return table
    


filepath = input("Enter the file path to the input file : ")
file1 = open(filepath, 'r')
lines = file1.readlines()
points=[]
for l in lines:
    x,y = l.split(' ')
    x = float(x)
    y = float(y)
    d=[]
    d.append(x)
    d.append(y)
    points.append(d)
file1.close()

#Uncomment the below line to test for the given sample points
#points = [[0, -4], [0.5, -2], [2, -3.75], [4, -4.25], [4.5, -0.5], [3, -2.5], [0.25, 2], [-3, -2.5]]

vert = [[0 for j in range(len(points))] for i in range(len(points))]
print(points)
n = len(points)
fig = plt.figure(figsize=( 8, 20))
ax1 = fig.add_subplot(511)
ax1.set_title('Min sum of diagonals')
ax2 = fig.add_subplot(512)
ax2.set_title('Min difference between longest and shortest side of triangles')
ax3 = fig.add_subplot(513)
ax3.set_title('Minimizing the max area triangle')
ax4 = fig.add_subplot(514)
ax4.set_title('Minimizing the max perimeter triangle')
ax5 = fig.add_subplot(515)
ax5.set_title('Ear-clipping triangulation')

for i, x in enumerate(points):
    vert[i] = vertex()
    vert[i].x = points[i][0]
    vert[i].y = points[i][1]
    x_values = [points[i][0], points[(i + 1) % n][0]]
    y_values = [points[i][1], points[(i + 1) % n][1]]
    ax1.plot(x_values, y_values, color='b')
    ax2.plot(x_values, y_values, color='b')
    ax3.plot(x_values, y_values, color='b')
    ax4.plot(x_values, y_values, color='b')
    ax5.plot(x_values, y_values, color='b')

vert1 = vert
P_opt_diag = [[-1 for i in range(n)] for j in range(n)]
P_opt_sides = [[-1 for i in range(n)] for j in range(n)]
P_opt_area = [[-1 for i in range(n)] for j in range(n)]
P_opt_peri = [[-1 for i in range(n)] for j in range(n)]

#Preprocessing and building the visibility graph
vis = buildVisibility(vert, n)

optlen1 = optimalTri(vert, n, vis, P_opt_diag)[n - 1][0]
optlen2 = optimalAngleTri(vert,n, vis, P_opt_sides)[n-1][0]
optlen3 = optimalAreaTri(vert, n, vis, P_opt_area)[n-1][0]
optlen4 = optimalPerimeterTri(vert, n, vis, P_opt_peri)[n-1][0]

print('Sum of diagonals of the triangulation with Dynamic programming - ', optlen1)
plot_tri(P_opt_diag, vert, n - 1, 0, n, ax1, 'r')
plot_tri(P_opt_sides, vert, n - 1, 0, n, ax2, 'g')
plot_tri(P_opt_area, vert, n - 1, 0, n, ax3, 'c')
plot_tri(P_opt_peri, vert, n - 1, 0, n, ax4, 'm')

EarClipTriangulate(n, vert1, ax5)
print('Sum of diagonals of the triangulation with Ear-clipping - ', length)
plt.show()